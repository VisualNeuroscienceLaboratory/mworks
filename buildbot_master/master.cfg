# -*- python -*-
# ex: set syntax=python:

from buildbot.buildslave import BuildSlave
from buildbot.scheduler import Scheduler, Nightly, Triggerable

from buildbot.process import factory
from buildbot.steps import source, shell, transfer
from buildbot.steps.trigger import Trigger
from buildbot.steps.python_twisted import Trial

import imp
import os
import sys
import time


# ==========================================================
# Definitions
# ==========================================================

current_branch = "master"
current_branch_name = current_branch
checkout_type = "update"
standard_mac_arch = "i386-OSX-10.5"
standard_linux_arch = 'a64-debian'

mw_library_directory = "/Library/Application Support/MonkeyWorks"
mw_test_directory = mw_library_directory + "/Developer/test"
mw_project_name = "MonkeyWorks"

repository_base_url = "git://github.com/monkeyworks-project/" 

installer_destination_path = "/home/coxlab/webapps/public/"

# ==========================================================
# Build Master Base Configuration
# ==========================================================

c = BuildmasterConfig = {}

# ----------------------------------------------------------------
# TODO: Must edit the slave passwords 
slave_pass = os.getlogin()
#raise Exception("You must edit the slave users before you can use this configuration")
# ----------------------------------------------------------------

c['slaves'] = [BuildSlave(standard_mac_arch, slave_pass)]
c['slavePortnum'] = 7355

c['projectName'] = mw_project_name
c['projectURL'] = "http://monkeyworks-project.github.com"

# the 'buildbotURL' string should point to the location where the buildbot's
# internal web server (usually the html.Waterfall page) is visible. This
# typically uses the port number set in the Waterfall 'status' entry, but
# with an externally-visible host name which the buildbot cannot figure out
# without some help.
c['buildbotURL'] = "http://monkeyworks.coxlab.org"
c['buildbot'] = "http://monkeyworks.coxlab.org:7349"



# ==========================================================
# Helper Classes 
# ==========================================================
class XCodeBuildFactory(factory.BuildFactory):
        
    def __init__(self, vcs, build_targets, configuration="Release"):

        factory.BuildFactory.__init__(self)
        
        # check out the sources
        self.addStep(vcs)
        
        for target in build_targets:
            self.addStep(shell.ShellCommand(command=["xcodebuild", "clean", "-target", target, "-configuration", configuration], 
                                              descriptionDone=["cleaned"],
                                              description=["cleaning"]))
            self.addStep(shell.ShellCommand(command=["xcodebuild", "build", "-target", target, "-configuration", configuration],
                                          descriptionDone=["built"],
                                          description=["building"]))

class PathCleanerFactory(factory.BuildFactory):

    def __init__(self, paths):
        factory.BuildFactory.__init__(self)
        for path in paths:
            self.addStep(shell.ShellCommand(description=["cleaning", mw_project_name],
                                                               descriptionDone=["preparing", path],
                                                               command=["mkdir", "-p", path]))
            self.addStep(shell.ShellCommand(description=["cleaning", mw_project_name],
                                                               descriptionDone=["adjusting permissions", path],
                                                               command=["chmod", "-R", "+rwx", path]))
            self.addStep(shell.ShellCommand(description=["cleaning", path],
                                                               descriptionDone=["cleaned", path],
                                                               command=["rm", "-rf", path]))



# ==========================================================
# Projects to build
# ==========================================================

# Here are a listing of possible targets (i.e. projects) to build
# For the "base" targets, definitions will be included later in this
# file.  
# For the "plugin" targets, we will dynamically load a module by this
# name, and get the build instructions from there 
base_projects = [ "clean_all",
                  "required_libs", 
                  "editor",
                  "scarab", 
                  "example_xml", 
                  "core",
                  "cppunit_core_tests",
                  "cocoa", 
                  "server",
                  "client",
                  "installer",
                  "marionette_tests1"
                  ]

plugins_path = os.getcwd() + "/plugins"
sys.path.append(plugins_path)
plugin_names = os.listdir(plugins_path)
#os.chdir("./plugins")
plugin_builders = []
plugin_schedulers = []
plugins = []

for plugin_name in plugin_names:
    try:
        tokens = plugin_name.split(".")
        if(tokens[-1] != 'py'):
            continue
        mod_name = tokens[0]
        print("Importing plugin: %s" % mod_name)
        (f,fn,info) = imp.find_module(mod_name)
        module = imp.load_module(mod_name, f, fn, info)
    except Exception,e:
        print("Failed to import plugin %s: %s" % (plugin_name, e.message))
        continue
        
    plugins.append(module)
    
    # Get the names of projects defined in the module out of
    # the plugin module's namespace
    
    (these_schedulers, these_builders) = module.get_plugins()
    print("Got %d schedulers from %s" % (len(these_schedulers), plugin_name))
    for sched in these_schedulers:
        plugin_schedulers.append(sched)
    
    for builder in these_builders:
        plugin_builders.append(builder)


# ==========================================================
# Schedulers
# ==========================================================

schedulers = []

# This is the standard "nightly" build (i.e. it is run every night using the latest trunk sources)
nightly = Nightly(name="nightly", builderNames=["build_all"], hour=[0], minute=[0], branch=None);
schedulers.append(nightly)

# Generate Triggerable objects for each of the "base" projects
for project_name in base_projects:
    schedulers.append(Triggerable(name=project_name, builderNames=[project_name]))


# Ask each of the plugins for a list of scheduler objects
# for plugin in plugins:
#     if(plugin == None):
#         continue
# 
#     if(plugin.schedulers.__class__ != list):
#         raise Exception, "Plugin contains an invalid schedulers list"
# 
#     # take the list of schedulers out of the plugin module's namespace
#     # and append to the schedulers list
#     schedulers += plugin.schedulers

for sched in plugin_schedulers:
    schedulers.append(sched)

print("All schedulers:")
print("---------------")
for scheduler in schedulers:
    print(scheduler.name)

c['schedulers'] = schedulers 


# ==========================================================
# Builders
# ==========================================================

# the 'builders' list defines the Builders, which define how each
# component is built. Each one is configured with a
# dictionary, using the following keys:
#  name (required): the name used to describe this bilder
#  slavename (required): which slave to use, must appear in c['bots']
#  builddir (required): which subdirectory to run the builder in
#  factory (required): a BuildFactory to define how the build is run
#  periodicBuildTime (optional): if set, force a build every N seconds

# buildbot/process/factory.py provides several BuildFactory classes you can
# start with, which implement build processes for common targets (GNU
# autoconf projects, CPAN perl modules, etc). The factory.BuildFactory is the
# base class, and is configured with a series of BuildSteps. When the build
# is run, the appropriate buildslave is told to execute each Step in turn.

# the first BuildStep is typically responsible for obtaining a copy of the
# sources. There are source-obtaining Steps in buildbot/process/step.py for
# CVS, SVN, and others.


builders = []

# ==========================================================
# build_all_factory
# ==========================================================

build_all_factory = factory.BuildFactory()
build_all_factory.addStep(Trigger(schedulerNames=['clean_all'], waitForFinish=True, updateSourceStamp=False))
build_all_factory.addStep(Trigger(schedulerNames=['required_libs'], waitForFinish=True, updateSourceStamp=False))
build_all_factory.addStep(Trigger(schedulerNames=['scarab'], waitForFinish=True, updateSourceStamp=False))
build_all_factory.addStep(Trigger(schedulerNames=['core'], waitForFinish=True, updateSourceStamp=False))
build_all_factory.addStep(Trigger(schedulerNames=['cppunit_core_tests'], waitForFinish=True, updateSourceStamp=False))

print "Adding plugin schedulers"
for plugin_scheduler in plugin_schedulers:
    print("Adding scheduler %s to build_all" % plugin_scheduler.name)
    build_all_factory.addStep(Trigger(schedulerNames=[plugin_scheduler.name], waitForFinish=False, updateSourceStamp=False))

build_all_factory.addStep(Trigger(schedulerNames=['example_xml'], waitForFinish=True, updateSourceStamp=False))
build_all_factory.addStep(Trigger(schedulerNames=['marionette 1 tests'], waitForFinish=True, updateSourceStamp=False))
build_all_factory.addStep(Trigger(schedulerNames=['marionette 2 tests'], waitForFinish=True, updateSourceStamp=False))

build_all_factory.addStep(Trigger(schedulerNames=['cocoa'], waitForFinish=True, updateSourceStamp=False))
build_all_factory.addStep(Trigger(schedulerNames=['server'], waitForFinish=True, updateSourceStamp=False))

build_all_factory.addStep(Trigger(schedulerNames=['client'], waitForFinish=True, updateSourceStamp=False))
build_all_factory.addStep(Trigger(schedulerNames=['editor'], waitForFinish=True, updateSourceStamp=False))
build_all_factory.addStep(Trigger(schedulerNames=['installer'], waitForFinish=True, updateSourceStamp=False))


builder_name = "build_all"
build_all_builder = {'name': builder_name,
      'slavename': standard_mac_arch,
      'builddir': builder_name,
      'factory': build_all_factory,
      }

# Add it to the running list
builders.append(build_all_builder)


# ==========================================================
# clean_monkeyworks_factory
# ==========================================================

clean_monkeyworks_factory = PathCleanerFactory([mw_library_directory,
                                             "/Library/Frameworks/MonkeyWorksCore.framework",
                                             "/Library/Frameworks/MonkeyWorksCocoa.framework",
                                             "/Library/Frameworks/MonkeyWorksCocoa.framework",
                                             "/Library/Application Support/MWClient",
                                             "/Applications/MWClient.app",
                                             "/Applications/MWServer.app",
                                             "/Applications/MWEditor.app"])

builder_name = "clean_all"
clean_monkeyworks_builder = {'name': builder_name,
                  'slavename': standard_mac_arch,
                  'builddir': builder_name,
                  'factory': clean_monkeyworks_factory,
                  }

builders.append(clean_monkeyworks_builder)

# ==========================================================
# editor_factory
# ==========================================================

builder_name = "editor"
editor_builder = {'name': builder_name,
                  'slavename': standard_mac_arch,
                  'builddir': builder_name,
                  'factory': XCodeBuildFactory(source.Git(repository_base_url + "mw_editor.git", current_branch, mode=checkout_type),
                                              ["MWEditor"], "Debug"),
                  }

builders.append(editor_builder)

# ==========================================================
# required_libs_factory
# ==========================================================

required_libs_factory = factory.BuildFactory()
required_libs_factory.addStep(source.Git(repository_base_url + "mw_supporting.git", current_branch, mode=checkout_type))
required_libs_factory.addStep(shell.ShellCommand(command=["make", "clean"]))
required_libs_factory.addStep(shell.ShellCommand(command=["make", "all"]))

builder_name = "required_libs"
required_libs_builder = {'name': builder_name,
                          'slavename': standard_mac_arch,
                          'builddir': builder_name,
                          'factory': required_libs_factory,
                          }

builders.append(required_libs_builder)


# ==========================================================
# example_xml_factory
# ==========================================================


builder_name = "example_xml"
example_xml_builder = {'name': builder_name,
                          'slavename': standard_mac_arch,
                          'builddir': builder_name,
                          'factory': XCodeBuildFactory(source.Git(repository_base_url + "mw_examples.git", current_branch, mode=checkout_type),
                                                       ["InstallTests"]),
                          }

builders.append(example_xml_builder)

# ==========================================================
# scarab_factory
# ==========================================================


builder_name = "scarab"
scarab_builder = {'name': builder_name,
                  'slavename': standard_mac_arch,
                  'builddir': builder_name,
                  'factory': XCodeBuildFactory(source.Git(repository_base_url + "mw_scarab.git", current_branch, mode=checkout_type),
                                               ["ScarabUninstall", "libscarab.a"], "Development"),
                  }
                  
builders.append(scarab_builder)

# ==========================================================
# core_factory
# ==========================================================


builder_name = "core"
core_builder = {'name': builder_name,
      'slavename': standard_mac_arch,
      'builddir': builder_name,
      'factory': XCodeBuildFactory(source.Git(repository_base_url + "mw_core.git", current_branch, mode=checkout_type),
                                   ["CoreUninstall", "Everything"], "Development"),
      }
      
builders.append(core_builder)


# ==========================================================
# cppunit_core_tests_factory
# ==========================================================


cppunit_core_tests_factory = factory.BuildFactory()
cppunit_core_tests_factory.addStep(shell.ShellCommand(command=[mw_test_directory + "/MonkeyWorksCoreTestRunner"],
                                                 descriptionDone=["finish"],
                                                 description=["running"]))


builder_name = "cppunit_core_tests"
cppunit_test_builder = {'name': builder_name,
      'slavename': standard_mac_arch,
      'builddir': builder_name,
      'factory': cppunit_core_tests_factory,
      }

builders.append(cppunit_test_builder)



# ==========================================================
# Marionette Test Builders
# ==========================================================


marionette_tests_1_factory = factory.BuildFactory()
#marionette_tests_2_factory = factory.BuildFactory()


class MarionetteTest(shell.ShellCommand):
    
    def __init__(self, base_dir, test_path):
        marionette_test_app = "MarionetteTest.app/Contents/MacOS/MarionetteTest"
        default_data_path = "MarionetteTest.app/Contents/Resources/default_test_data.xml"
        shell.ShellCommand.__init__(self, command=[ base_dir + "/" + marionette_test_app,
                                                    base_dir + "/XML/"+test_path,
                                                    base_dir + "/" + default_data_path],
                                          descriptionDone=[test_path, "completed"],
                                          description=[test_path, "running"])


marionette_test_paths = ["ABatteryOfBasicTests/AssertTest.xml"]

for test_path in marionette_test_paths:
    marionette_tests_1_factory.addStep(MarionetteTest(mw_test_directory, test_path))


builder_name = "marionette_tests1"
marionette_tests_1_builder = {'name': builder_name,
                              'slavename': standard_mac_arch,
                              'builddir': builder_name,
                              'factory': marionette_tests_1_factory,
                              }

builders.append(marionette_tests_1_builder)

# ==========================================================
# MonkeyWorksCocoa Builder
# ==========================================================


builder_name = "cocoa"
cocoa_builder = {'name': builder_name,
      'slavename': standard_mac_arch,
      'builddir': builder_name,
      'factory': XCodeBuildFactory(source.Git(repository_base_url + "mw_cocoa.git", current_branch, mode=checkout_type),
                                   ["UninstallMWCocoa", "MonkeyWorksCocoa"], "Development")
      }

builders.append(cocoa_builder)

# ==========================================================
# Server Builder
# ==========================================================

builder_name = "server"
server_builder = {'name': builder_name,
      'slavename': standard_mac_arch,
      'builddir': builder_name,
      'factory': XCodeBuildFactory(source.Git(repository_base_url + "mw_server.git", current_branch, mode=checkout_type),
                                   ["UninstallServer", "MonkeyWorksServer"], "Development")
      }
builders.append(server_builder)


# ==========================================================
# Client Builder
# ==========================================================

builder_name = "client"
client_builder = {'name': builder_name,
      'slavename': standard_mac_arch,
      'builddir': builder_name,
      'factory': XCodeBuildFactory(source.Git(repository_base_url + "mw_client.git", current_branch, mode=checkout_type),
                                   ["MWClient"], "Debug")
      }
builders.append(client_builder)




installer_factory = factory.BuildFactory();
installer_factory.addStep(source.Git(repository_base_url + "mw_build.git", current_branch, mode=checkout_type))

installer_name = "MonkeyWorksInstaller"
now = time.gmtime()
installer_version = "NIGHTLY_%d_%d_%d" % (now[0], now[1], now[2])  # TODO: autogenerate fingerprint

installer_factory.addStep(shell.ShellCommand(command=["installer/build_installer_package.py",  installer_name, installer_version],   
                                                 descriptionDone=["built"],
                                                 description=["building"]))

installer_file_name = installer_name + "_" + installer_version + ".pkg"
installer_path = "/tmp/mw_installer/" + installer_file_name
full_installer_destination_path = installer_destination_path + "/" + installer_file_name
installer_factory.addStep(transfer.FileUpload(installer_path, full_installer_destination_path))
# installer_factory.addStep(shell.ShellCommand(command=["cp",  "-r", "installer/Archive/MonkeyWorks-NIGHTLY.mpkg.zip", "/Library/WebServer/Documents/MonkeyWorks"],
#                                                  descriptionDone=["copied"],
#                                                  description=["copying"]))

builder_name = "installer"
installer_builder = {'name': builder_name,
      'slavename': standard_mac_arch,
      'builddir': builder_name,
      'factory': installer_factory,
      }

builders.append(installer_builder)


# add all of the plugin builders
for pb in plugin_builders:
    builders.append(pb)


c['builders'] = builders



####### STATUS TARGETS

# 'status' is a list of Status Targets. The results of each build will be
# pushed to these targets. buildbot/status/*.py has a variety to choose from,
# including web pages, email senders, and IRC bots.

c['status'] = []

from buildbot.status import html
c['status'].append(html.WebStatus(http_port=7349, allowForce=True))

#from buildbot.status.mail import MailNotifier
#c['status'].append(MailNotifier(fromaddr="buildbot@localhost",
#                                extraRecipients=["bkennedy@mit.edu", "ben@andken.com"],
#                                sendToInterestedUsers=False,
#                                subject="%(builder)s is rebuilding MonkeyWorks",
#                                addLogs=True))
#
# from buildbot.status import words
# c['status'].append(words.IRC(host="irc.example.com", nick="bb",
#                              channels=["#example"]))
#
# from buildbot.status import client
# c['status'].append(client.PBListener(9988))


####### DEBUGGING OPTIONS

# if you set 'debugPassword', then you can connect to the buildmaster with
# the diagnostic tool in contrib/debugclient.py . From this tool, you can
# manually force builds and inject changes, which may be useful for testing
# your buildmaster without actually commiting changes to your repository (or
# before you have a functioning 'sources' set up). The debug tool uses the
# same port number as the slaves do: 'slavePortnum'.

#c['debugPassword'] = "debugpassword"

# if you set 'manhole', you can ssh into the buildmaster and get an
# interactive python shell, which may be useful for debugging buildbot
# internals. It is probably only useful for buildbot developers. You can also
# use an authorized_keys file, or plain telnet.
#from buildbot import manhole
#c['manhole'] = manhole.PasswordManhole("tcp:9999:interface=127.0.0.1",
#                                       "admin", "password")




