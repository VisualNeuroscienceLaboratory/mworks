# -*- python -*-
# ex: set syntax=python:

from buildbot.buildslave import BuildSlave
from buildbot.scheduler import Scheduler, Nightly, Triggerable

from buildbot.process import factory
from buildbot.process.properties import WithProperties
from buildbot.steps import source, shell, transfer
from buildbot.steps.trigger import Trigger
from buildbot.steps.python_twisted import Trial

import imp
import os
import sys
import time


# ==========================================================
# Definitions
# ==========================================================

current_branch = "master"
current_branch_name = current_branch
checkout_type = "update"

mac_i386_10_5_arch = "i386-OSX-10.5"
mac_x86_64_10_5_arch = "x86_64-OSX-10.5"
mac_x86_64_10_6_arch = "x86_64-OSX-10.6"

standard_mac_arch = mac_x86_64_10_6_arch
standard_linux_arch = 'a64-debian'

standard_xcode_build_config = "Development (10.5 Compatible)"
all_test_archs = ('i386', 'x86_64')
default_test_arch = 'x86_64'

mw_library_directory = "/Library/Application Support/MonkeyWorks"
mw_config_directory = mw_library_directory + '/Configuration'
mw_test_directory = mw_library_directory + "/Developer/tests"
mw_data_directory = '/Documents/MonkeyWorks/Data'
mw_project_name = "MWorks"

from local_config import *
from slave_pass import *

# ==========================================================
# Build Master Base Configuration
# ==========================================================

c = BuildmasterConfig = {}

c['slaves'] = [BuildSlave(standard_mac_arch, slave_pass)]
c['slavePortnum'] = 7355

c['projectName'] = mw_project_name
c['projectURL'] = project_url

# the 'buildbotURL' string should point to the location where the buildbot's
# internal web server (usually the html.Waterfall page) is visible. This
# typically uses the port number set in the Waterfall 'status' entry, but
# with an externally-visible host name which the buildbot cannot figure out
# without some help.
c['buildbotURL'] = "http://%s:7349" % buildbot_hostname



# ==========================================================
# Helper Classes 
# ==========================================================
class XCodeBuildFactory(factory.BuildFactory):
        
    def __init__(self, vcs, build_targets, configuration="Release"):

        factory.BuildFactory.__init__(self)
        
        # check out the sources
        self.addStep(vcs)
        
        for target in build_targets:
            self.addStep(shell.ShellCommand(command=["sh", "-c", "xcodebuild clean -target %s -configuration \"%s\"" % (target, configuration)],
            #["xcodebuild", "clean", "-target", target, "-configuration", configuration], 
                                              descriptionDone=["cleaned"],
                                              description=["cleaning"]))
            self.addStep(shell.ShellCommand( command=["sh", "-c", "xcodebuild build -target %s -configuration \"%s\"" % (target, configuration)],
            #command=["xcodebuild", "build", "-target", target, "-configuration", configuration],
                                          descriptionDone=["built"],
                                          description=["building"]))

class PathCleanerFactory(factory.BuildFactory):

    def __init__(self, paths):
        factory.BuildFactory.__init__(self)
        for path in paths:
            self.addStep(shell.ShellCommand(description=["cleaning", mw_project_name],
                                                               descriptionDone=["preparing", path],
                                                               command=["mkdir", "-p", path]))
            self.addStep(shell.ShellCommand(description=["cleaning", mw_project_name],
                                                               descriptionDone=["adjusting permissions", path],
                                                               command=["chmod", "-R", "+rwx", path]))
            self.addStep(shell.ShellCommand(description=["cleaning", path],
                                                               descriptionDone=["cleaned", path],
                                                               command=["rm", "-rf", path]))



# ==========================================================
# Projects to build
# ==========================================================

# Here are a listing of possible targets (i.e. projects) to build
# For the "base" targets, definitions will be included later in this
# file.  
# For the "plugin" targets, we will dynamically load a module by this
# name, and get the build instructions from there 
base_projects = [ "clean_all",
                  "required_libs", 
                  "scarab", 
                  "core",
                  "test_setup",
                  "cppunit_core_tests",
                  "example_xml", 
                  "marionette_tests1",
                  "test_cleanup",
                  "cocoa", 
                  "server",
                  "client",
                  "editor",
                  "installer",
                  "build_all",
                  "test_all",
                  ]

plugins_path = os.getcwd() + "/plugins"
sys.path.append(plugins_path)
plugin_names = os.listdir(plugins_path)
#os.chdir("./plugins")
plugin_builders = []
plugin_schedulers = []
plugins = []

for plugin_name in plugin_names:
    try:
        tokens = plugin_name.split(".")
        if(tokens[-1] != 'py'):
            continue
        mod_name = tokens[0]
        print("Importing plugin: %s" % mod_name)
        (f,fn,info) = imp.find_module(mod_name)
        module = imp.load_module(mod_name, f, fn, info)
    except Exception,e:
        print("Failed to import plugin %s: %s" % (plugin_name, e.message))
        continue
        
    plugins.append(module)
    
    # Get the names of projects defined in the module out of
    # the plugin module's namespace
    
    (these_schedulers, these_builders) = module.get_plugins(standard_mac_arch=standard_mac_arch)
    print("Got %d schedulers from %s" % (len(these_schedulers), plugin_name))
    for sched in these_schedulers:
        plugin_schedulers.append(sched)
    
    for builder in these_builders:
        plugin_builders.append(builder)


# ==========================================================
# Schedulers
# ==========================================================

schedulers = []

# This is the standard "nightly" build (i.e. it is run every night using the latest trunk sources)
nightly = Nightly(name="nightly", builderNames=["build_and_test_all"], hour=[0], minute=[0], branch=None);
schedulers.append(nightly)

# Generate Triggerable objects for each of the "base" projects
for project_name in base_projects:
    schedulers.append(Triggerable(name=project_name, builderNames=[project_name]))


# Ask each of the plugins for a list of scheduler objects
# for plugin in plugins:
#     if(plugin == None):
#         continue
# 
#     if(plugin.schedulers.__class__ != list):
#         raise Exception, "Plugin contains an invalid schedulers list"
# 
#     # take the list of schedulers out of the plugin module's namespace
#     # and append to the schedulers list
#     schedulers += plugin.schedulers

for sched in plugin_schedulers:
    schedulers.append(sched)

print("All schedulers:")
print("---------------")
for scheduler in schedulers:
    print(scheduler.name)

c['schedulers'] = schedulers 


# ==========================================================
# Builders
# ==========================================================

# the 'builders' list defines the Builders, which define how each
# component is built. Each one is configured with a
# dictionary, using the following keys:
#  name (required): the name used to describe this bilder
#  slavename (required): which slave to use, must appear in c['bots']
#  builddir (required): which subdirectory to run the builder in
#  factory (required): a BuildFactory to define how the build is run
#  periodicBuildTime (optional): if set, force a build every N seconds

# buildbot/process/factory.py provides several BuildFactory classes you can
# start with, which implement build processes for common targets (GNU
# autoconf projects, CPAN perl modules, etc). The factory.BuildFactory is the
# base class, and is configured with a series of BuildSteps. When the build
# is run, the appropriate buildslave is told to execute each Step in turn.

# the first BuildStep is typically responsible for obtaining a copy of the
# sources. There are source-obtaining Steps in buildbot/process/step.py for
# CVS, SVN, and others.


builders = []

# ==========================================================
# build_and_test_all_factory
# ==========================================================

build_and_test_all_factory = factory.BuildFactory()

build_and_test_all_factory.addStep(Trigger(schedulerNames=['build_all'], waitForFinish=True, updateSourceStamp=False))
build_and_test_all_factory.addStep(Trigger(schedulerNames=['test_all'], waitForFinish=True, updateSourceStamp=False))

builder_name = "build_and_test_all"
build_and_test_all_builder = {'name': builder_name,
      'slavename': standard_mac_arch,
      'builddir': builder_name,
      'factory': build_and_test_all_factory,
      }

# Add it to the running list
builders.append(build_and_test_all_builder)

# ==========================================================
# build_all_factory
# ==========================================================

build_all_factory = factory.BuildFactory()
build_all_factory.addStep(Trigger(schedulerNames=['clean_all'], waitForFinish=True, updateSourceStamp=False))
build_all_factory.addStep(Trigger(schedulerNames=['required_libs'], waitForFinish=True, updateSourceStamp=False))
build_all_factory.addStep(Trigger(schedulerNames=['scarab'], waitForFinish=True, updateSourceStamp=False))
build_all_factory.addStep(Trigger(schedulerNames=['core'], waitForFinish=True, updateSourceStamp=False))

build_all_factory.addStep(Trigger(schedulerNames=['example_xml'], waitForFinish=True, updateSourceStamp=False))

build_all_factory.addStep(Trigger(schedulerNames=['cocoa'], waitForFinish=True, updateSourceStamp=False))
build_all_factory.addStep(Trigger(schedulerNames=['server'], waitForFinish=True, updateSourceStamp=False))

build_all_factory.addStep(Trigger(schedulerNames=['client'], waitForFinish=True, updateSourceStamp=False))
build_all_factory.addStep(Trigger(schedulerNames=['editor'], waitForFinish=True, updateSourceStamp=False))

print "Adding plugin schedulers"
for plugin_scheduler in plugin_schedulers:
    print("Adding scheduler %s to build_all" % plugin_scheduler.name)
    build_all_factory.addStep(Trigger(schedulerNames=[plugin_scheduler.name], waitForFinish=True, updateSourceStamp=False))

build_all_factory.addStep(Trigger(schedulerNames=['installer'], waitForFinish=True, updateSourceStamp=False))


builder_name = "build_all"
build_all_builder = {'name': builder_name,
      'slavename': standard_mac_arch,
      'builddir': builder_name,
      'factory': build_all_factory,
      }

# Add it to the running list
builders.append(build_all_builder)

# ==========================================================
# test_all_factory
# ==========================================================

test_all_factory = factory.BuildFactory()

for test_arch in all_test_archs:
    for scheduler_name in ('test_setup',
                           'cppunit_core_tests',
                           'marionette_tests1',
                           'test_cleanup'):
        test_all_factory.addStep(Trigger(schedulerNames = [scheduler_name],
                                         waitForFinish = True,
                                         updateSourceStamp = False,
                                         set_properties = {'test_arch': test_arch},
                                         ))

builder_name = "test_all"
test_all_builder = {'name': builder_name,
      'slavename': standard_mac_arch,
      'builddir': builder_name,
      'factory': test_all_factory,
      }

builders.append(test_all_builder)


# ==========================================================
# clean_monkeyworks_factory
# ==========================================================

clean_monkeyworks_factory = PathCleanerFactory([mw_library_directory,
                                                "/Library/Frameworks/MonkeyWorksCore.framework",
                                                "/Library/Frameworks/MonkeyWorksCocoa.framework",
                                                "/Documents/MonkeyWorks",
                                                "/Applications/MWClient.app",
                                                "/Applications/MWServer.app",
                                                "/Applications/MWEditor.app"])

builder_name = "clean_all"
clean_monkeyworks_builder = {'name': builder_name,
                  'slavename': standard_mac_arch,
                  'builddir': builder_name,
                  'factory': clean_monkeyworks_factory,
                  }

builders.append(clean_monkeyworks_builder)

# ==========================================================
# required_libs_factory
# ==========================================================

required_libs_factory = factory.BuildFactory()
required_libs_factory.addStep(source.Git(repository_base_url + "mw_supporting.git", current_branch, mode='clobber'))
required_libs_factory.addStep(shell.ShellCommand(command=["git", "submodule", "update", "--init"]))
required_libs_factory.addStep(shell.ShellCommand(command=["python", "fresh_build.py"]))

builder_name = "required_libs"
required_libs_builder = {'name': builder_name,
                          'slavename': standard_mac_arch,
                          'builddir': builder_name,
                          'factory': required_libs_factory,
                          }

builders.append(required_libs_builder)

# ==========================================================
# scarab_factory
# ==========================================================


builder_name = "scarab"
scarab_builder = {'name': builder_name,
                  'slavename': standard_mac_arch,
                  'builddir': builder_name,
                  'factory': XCodeBuildFactory(source.Git(repository_base_url + "mw_scarab.git", current_branch, mode=checkout_type),
                                               ["libscarab.a"], standard_xcode_build_config),
                  }
                  
builders.append(scarab_builder)

# ==========================================================
# core_factory
# ==========================================================


builder_name = "core"
core_builder = {'name': builder_name,
      'slavename': standard_mac_arch,
      'builddir': builder_name,
      'factory': XCodeBuildFactory(source.Git(repository_base_url + "mw_core.git", current_branch, mode=checkout_type),
                                   ["Everything"], standard_xcode_build_config),
      }
      
builders.append(core_builder)


# ==========================================================
# test_setup_factory
# ==========================================================


test_setup_factory = factory.BuildFactory()

test_setup_factory.addStep(shell.ShellCommand(command=['cp',
                                                       '-f',
                                                       mw_config_directory + '/examples/setup_variables_macbook.xml',
                                                       mw_config_directory + '/setup_variables.xml'],
                                              descriptionDone=['create', 'config', 'file'],
                                              description=['creating', 'config', 'file']))

test_setup_factory.addStep(shell.ShellCommand(command=['mkdir', '-p', mw_data_directory],
                                              descriptionDone=['create', 'data', 'dir'],
                                              description=['creating', 'data', 'dir']))


builder_name = "test_setup"
test_setup_builder = {'name': builder_name,
      'slavename': standard_mac_arch,
      'builddir': builder_name,
      'factory': test_setup_factory,
      }

builders.append(test_setup_builder)


# ==========================================================
# cppunit_core_tests_factory
# ==========================================================


cppunit_core_tests_factory = factory.BuildFactory()
cppunit_core_tests_factory.addStep(shell.ShellCommand(
        command = [
            '/usr/bin/arch',
            WithProperties('-%(test_arch:-' + default_test_arch + ')s'),
            mw_test_directory + "/MonkeyWorksCoreTestRunner",
            ],
        descriptionDone = ["finish"],
        description = ["running"],
        ))


builder_name = "cppunit_core_tests"
cppunit_test_builder = {'name': builder_name,
      'slavename': standard_mac_arch,
      'builddir': builder_name,
      'factory': cppunit_core_tests_factory,
      }

builders.append(cppunit_test_builder)


# ==========================================================
# example_xml_factory
# ==========================================================


builder_name = "example_xml"
example_xml_builder = {'name': builder_name,
                          'slavename': standard_mac_arch,
                          'builddir': builder_name,
                          'factory': XCodeBuildFactory(source.Git(repository_base_url + "mw_examples.git", current_branch, mode=checkout_type),
                                                       ["InstallTests"], 'Release'),
                          }

builders.append(example_xml_builder)



# ==========================================================
# Marionette Test Builders
# ==========================================================


# tried to do this with inheritance, but buildbot does something funky
class MarionetteTestFactory(factory.BuildFactory):

    def __init__(self, basedir, tests_to_run):
        factory.BuildFactory.__init__(self)
    
        marionette_test_app = basedir + "/MarionetteTest.app/Contents/MacOS/MarionetteTest"
        default_data_path = "/MarionetteTest.app/Contents/Resources/default_test_data.xml"
    
        
        for test_to_run in tests_to_run:
            test_path = None
            data_path = None
            if(test_to_run.__class__ == tuple):
                test_path = basedir + "/XML/" + test_to_run[0]
                data_path = basedir + "/XML/" + test_to_run[1]
            else:
                test_path = basedir + "/XML/" + test_to_run
                data_path = basedir + default_data_path

            
            #print("TEST: %s %s %s" % (marionette_test_app, test_path, data_path))
            self.addStep(shell.ShellCommand(
                    command = [
                        '/usr/bin/arch',
                        WithProperties('-%(test_arch:-' + default_test_arch + ')s'),
                        marionette_test_app,
                        test_path,
                        data_path,
                        ],
                    descriptionDone = [test_path, "completed"],
                    description = [test_path, "running"],
                    timeout=1200,
                    ))
        

# A simple little in-place ditty.  Recursively find all of the test file names
# If there is a corresponding TESTDATA.xml file, include that in a tuple
def recursive_get_xml_files(basedir, prefix=""):
    xml_files = []
    dir_contents = os.listdir(basedir)
    for filename in dir_contents:
        full_filename = basedir + "/" + filename
        split_name = filename.split(".")
        if(split_name[-1] == "xml" and split_name[-2] != "TESTDATA"):
            base_name = ""
            base_name = base_name.join(split_name[0:-1])
            testdata_name = basedir + "/" + base_name + ".TESTDATA.xml"
            if(os.path.exists(testdata_name)):
                xml_files.append((prefix+filename, prefix+base_name + ".TESTDATA.xml"))
            else:
                xml_files.append(prefix + filename)
        if(os.path.isdir(full_filename)):
            xml_files += recursive_get_xml_files(full_filename, prefix + filename + "/")
    return xml_files

marionette_test_paths = recursive_get_xml_files(mw_test_directory + "/XML")

print "MARIONETTE TEST PATHS"
print marionette_test_paths

marionette_tests_1_factory = MarionetteTestFactory(mw_test_directory, marionette_test_paths)

builder_name = "marionette_tests1"
marionette_tests_1_builder = {'name': builder_name,
                              'slavename': standard_mac_arch,
                              'builddir': builder_name,
                              'factory': marionette_tests_1_factory,
                              }

builders.append(marionette_tests_1_builder)


# ==========================================================
# test_cleanup_factory
# ==========================================================


test_cleanup_factory = factory.BuildFactory()

test_cleanup_factory.addStep(shell.ShellCommand(command=['rm', '-f', mw_config_directory + '/setup_variables.xml'],
                                                descriptionDone=['delete', 'config', 'file'],
                                                description=['deleting', 'config', 'file']))

test_cleanup_factory.addStep(shell.ShellCommand(command = ('rm -f %s/MARIONETTE.*.mwk' % mw_data_directory),
                                                descriptionDone=['clean', 'data', 'dir'],
                                                description=['cleaning', 'data', 'dir']))

test_cleanup_factory.addStep(shell.ShellCommand(command = ('rm -Rf "%s/Experiment Cache/"*' % mw_library_directory),
                                                descriptionDone=['clean', 'experiment', 'cache'],
                                                description=['cleaning', 'experiment', 'cache']))

builder_name = "test_cleanup"
test_cleanup_builder = {'name': builder_name,
      'slavename': standard_mac_arch,
      'builddir': builder_name,
      'factory': test_cleanup_factory,
      }

builders.append(test_cleanup_builder)


# ==========================================================
# MonkeyWorksCocoa Builder
# ==========================================================


builder_name = "cocoa"
cocoa_builder = {'name': builder_name,
      'slavename': standard_mac_arch,
      'builddir': builder_name,
      'factory': XCodeBuildFactory(source.Git(repository_base_url + "mw_cocoa.git", current_branch, mode=checkout_type),
                                   ["Everything"], standard_xcode_build_config)
      }

builders.append(cocoa_builder)

# ==========================================================
# Server Builder
# ==========================================================

builder_name = "server"
server_builder = {'name': builder_name,
      'slavename': standard_mac_arch,
      'builddir': builder_name,
      'factory': XCodeBuildFactory(source.Git(repository_base_url + "mw_server.git", current_branch, mode=checkout_type),
                                   ["Everything"], standard_xcode_build_config)
      }
builders.append(server_builder)


# ==========================================================
# Client Builder
# ==========================================================

builder_name = "client"
client_builder = {'name': builder_name,
      'slavename': standard_mac_arch,
      'builddir': builder_name,
      'factory': XCodeBuildFactory(source.Git(repository_base_url + "mw_client.git", current_branch, mode=checkout_type),
                                   ["Everything"], standard_xcode_build_config)
      }
builders.append(client_builder)

# ==========================================================
# editor_factory
# ==========================================================

builder_name = "editor"
editor_builder = {'name': builder_name,
                  'slavename': standard_mac_arch,
                  'builddir': builder_name,
                  'factory': XCodeBuildFactory(source.Git(repository_base_url + "mw_editor.git", current_branch, mode=checkout_type),
                                              ["MWEditor"], standard_xcode_build_config),
                  }

builders.append(editor_builder)


# add all of the plugin builders
for pb in plugin_builders:
    builders.append(pb)




installer_factory = factory.BuildFactory();
installer_factory.addStep(source.Git(repository_base_url + "dicarlolab_mwbuild.git", current_branch, mode=checkout_type))

installer_name = "MWorks"
installer_version = "NIGHTLY"
installer_file_name = installer_name + "-" + installer_version + ".dmg"
installer_path = "/tmp/mw_installer/" + installer_file_name
full_installer_destination_path = installer_destination_path + "/" + installer_file_name

installer_factory.addStep(shell.ShellCommand(command=['./build_installer', installer_version],
                                             workdir='build/installer',
                                             descriptionDone=["build"],
                                             description=["building"]))

installer_factory.addStep(transfer.FileUpload(installer_path,
                                              full_installer_destination_path,
                                              mode=0644))

builder_name = "installer"
installer_builder = {'name': builder_name,
      'slavename': standard_mac_arch,
      'builddir': builder_name,
      'factory': installer_factory,
      }

builders.append(installer_builder)


c['builders'] = builders



####### STATUS TARGETS

# 'status' is a list of Status Targets. The results of each build will be
# pushed to these targets. buildbot/status/*.py has a variety to choose from,
# including web pages, email senders, and IRC bots.

c['status'] = []

from buildbot.status import html
c['status'].append(html.WebStatus(http_port=7349, allowForce=True))

#from buildbot.status.mail import MailNotifier
#c['status'].append(MailNotifier(fromaddr="buildbot@localhost",
#                                extraRecipients=["bkennedy@mit.edu", "ben@andken.com"],
#                                sendToInterestedUsers=False,
#                                subject="%(builder)s is rebuilding MonkeyWorks",
#                                addLogs=True))
#
# from buildbot.status import words
# c['status'].append(words.IRC(host="irc.example.com", nick="bb",
#                              channels=["#example"]))
#
# from buildbot.status import client
# c['status'].append(client.PBListener(9988))


####### DEBUGGING OPTIONS

# if you set 'debugPassword', then you can connect to the buildmaster with
# the diagnostic tool in contrib/debugclient.py . From this tool, you can
# manually force builds and inject changes, which may be useful for testing
# your buildmaster without actually commiting changes to your repository (or
# before you have a functioning 'sources' set up). The debug tool uses the
# same port number as the slaves do: 'slavePortnum'.

#c['debugPassword'] = "debugpassword"

# if you set 'manhole', you can ssh into the buildmaster and get an
# interactive python shell, which may be useful for debugging buildbot
# internals. It is probably only useful for buildbot developers. You can also
# use an authorized_keys file, or plain telnet.
#from buildbot import manhole
#c['manhole'] = manhole.PasswordManhole("tcp:9999:interface=127.0.0.1",
#                                       "admin", "password")




